# Java基础

20240420

### 数据类型

###### 基本数据类型

   计算机内存的最小存储单元是byte，一个字节就是一个8位二进制数。1k = 1024byte。

| 数据类型 | 占用字节数                                | 取值范围                                  | 默认值   |
| -------- | ----------------------------------------- | ----------------------------------------- | -------- |
| byte     | 1                                         | -128~127                                  | 0        |
| short    | 2                                         | -32768~32767                              | 0        |
| int      | 4                                         | -2147483648~2147483647                    | 0        |
| long     | 8                                         | -9223372036854775808~9223372036854775807  | 0L       |
| float    | 4                                         | ±3.40282347E+38F，精度为6-7位小数         | 0f       |
| double   | 8                                         | ±1.79769313486231570E+308，精度为15位小数 | 0d       |
| char     | 2                                         | 0~65535                                   | '\u0000' |
| boolean  | 仅占用1位，但JVM通常会把它表示为4字节整数 | false/true                                | false    |

###### 引用数据类型

   类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置

###### 常量

定义变量的时候如果加上final修饰符，就变成了常量。若常量初始化之后再次赋值会导致编译错误。

常量的作用是用有意义的变量名来避免Magic number

###### var关键字

编译器可以通过赋值语句自动推断出变量的类型（TODO：如果是多态赋值情况，是否适用？）

```java
var sb = new StringBuilder();
```

###### 变量的作用域

在语句块{}中定义的变量，它有一个作用域，就是从定义处开始，到语句块结束。超出了作用域引用这些变量，编译器会报错。在定义变量时要遵循作用于最小化原则，且不要重复使用变量名。

###### 整数运算

整数的除法对除数为0时运行时报错，但编译时不会报错。

整数运算结果超出范围时会溢出，但不会报错

```java
public class Main {
    public static void main(String[] args) {
        int x = 2147483640; //int最大值为2147483647
        int y = 15;
        int sum = x + y;
        System.out.println(sum); // -2147483641，x+15进位之后首位由0变1，因此变为负数
    }
}
```

###### 补码

整数是以补码的形式存储的，对于正数，其二进制表示就是其补码；对于负数，其绝对值的二进制表示取反后+1就是其补码。

首位为0代表是正数，首位为1代表是负数，例如int类型的-2147483648的补码计算过程为：

```java
十进制表示值：-2147483648
绝对值二进制：10000000 00000000 00000000 00000000
取反后的结果：01111111 11111111 11111111 11111111
加一后的结果：10000000 00000000 00000000 00000000
```

###### 移位运算

">>"是保留符号移位；">>>"是带符号移位，空出来的高位总是补0

对byte和short类型进行移位时，会首先转换为int再进行移位

###### 位运算

与：&，必须同时为1，结果才为1

或：|，只要有一个为1，结果就为1

非：~，0变成1,1变成0

异或：^，如果两个数不同，结果为1，否则为0

###### 类型自动提升与强制转型

在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型；整数与浮点数运算会自动提升到浮点数类型

也可以将结果强制转型，使用 (类型)，但超出范围的强制转换会导致错误的结果

###### 浮点数运算

精度丢失：由于浮点数在计算机中是通过二进制保存，例如0.1转换成二进制是一个无限循环小数，常常无法精确表示，因此浮点数运算会产生误差

浮点数的比较：由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数

```java
double a = 1.6;
double b = 0.3;
double d = 1.9;
System.out.println(a + b); //1.9000000000000001
System.out.println(a + b == d); //false
```

浮点数运算在除数为`0`时，不会报错，但会返回几个特殊值：

```java
double d1 = 0.0 / 0; // NaN
double d2 = 1.0 / 0; // Infinity
double d3 = -1.0 / 0; // -Infinity
```

###### 布尔运算

短路运算：对于&&和||，若提前确定结果，后续的计算不会再执行，直接返回结果

三元运算符：b ? x : y;

###### 字符类型

Java在内存中总是使用Unicode表示字符

要显示一个字符的Unicode编码，只需将`char`类型直接赋值给`int`类型即可

```java
int n1 = 'A'; // 字母“A”的Unicodde编码是65
int n2 = '中'; // 汉字“中”的Unicode编码是20013
```

还可以直接用转义字符`\u`+Unicode编码来表示一个字符：

```java
// 注意是十六进制:
char c3 = '\u0041'; // 'A'，因为十六进制0041 = 十进制65
char c4 = '\u4e2d'; // '中'，因为十六进制4e2d = 十进制20013
```

###### 字符串类型

[String为何要设计成不可变](https://blog.csdn.net/qq_31536117/article/details/134612327)

1. 安全性：确保字符串值不会在程序的任何地方被修改
2. 线程安全：如果线程更改了值，那么将在字符串池中创建一个新的字符串，而不是修改相同的值 ，因为不会有一个线程修改它的值，从而避免了线程安全问题
3. 性能：JVM可以对它们进行一些优化。例如，它可以将多个String对象指向相同的字符数组，以减少内存使用和GC的开销
4. 缓存：由于String是不可变的，它们可以被缓存以提高性能。例如，Java字符串池使用String缓存来存储频繁使用的字符串

###### 数组类型

特点：

1. 一旦创建后，大小就不可改变；
2. 所有元素初始化为默认值，引用数据类型为null；
3. 可以在定义数组时直接指定初始化元素，这样就不必写出数组大小，编译器自动推断

### 流程控制

##### 输入与输出

###### 格式化输出

使用System.out.printf()，通过占位符可以把参数格式化为指定格式

```java
double d = 3.1415926;
System.out.printf("%.2f\n", d); // 显示两位小数3.14
System.out.printf("%.4f\n", d); // 显示4位小数3.1416
```

| 占位符 | 说明                             |
| ------ | -------------------------------- |
| %d     | 格式化输出整数                   |
| %x     | 格式化输出十六进制整数           |
| %f     | 格式化输出浮点数                 |
| %e     | 格式化输出科学计数法表示的浮点数 |
| %s     | 格式化字符串                     |

注意，由于%表示占位符，因此连续两个%%才表示一个字符%本身。

###### 输入

创建Scanner对象并传入System.in，**`Scanner`会自动转换数据类型，因此不必手动转换**。

##### if判断

判断引用类型相等必须使用`equals()`方法

为了避免空指针错误，可以将要比较的常量放到前面，例如`if("hello".equals(str))`

##### switch多重选择

基本语法：

```java
switch (option) {
    case 1:
        do something;
        break; //不使用break将会发生“穿透”
    case 2:
        do something;
        break;
    default:
        do something;
        break;
}
```

###### switch新特性

从Java 12开始，`switch`语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要`break`语句：

```java
String fruit = "apple";
switch (fruit) {
case "apple" -> System.out.println("Selected apple");
case "pear" -> System.out.println("Selected pear");
case "mango" -> { //若有多条语句，需要用{}括起来
    System.out.println("Selected mango");
    System.out.println("Good choice!");
}
default -> System.out.println("No fruit selected");
}
```

使用新的`switch`语法还可以直接返回值：

```java
String fruit = "apple";
int opt = switch (fruit) {
    case "apple" -> 1;
    case "pear", "mango" -> 2;
    default -> 0;
}; // 注意赋值语句要以;结束
```

如果是复杂的语句，也可以通过yield返回值：

```java
String fruit = "orange";
int opt = switch (fruit) {
    case "apple" -> 1;
    case "pear", "mango" -> 2;
    default -> {
        int code = fruit.hashCode();
        yield code; // switch语句返回值
    }
};
```

##### while循环

##### for循环

使用for循环时，最好不要在循环体内修改计数器，容易导致莫名其妙的逻辑错误。

##### for each循环

和for循环相比，for each循环的变量n不再是计数器，而是直接对应到数组的每个元素。该循环方式无法指定遍历顺序（数组遍历为顺序），也无法获取数组的索引。

for each循环能够遍历所有“可迭代”的数据类型，如List、Map等。

##### break和continue

break用于跳出自己所在的那一层循环；continue则是提前结束本次循环，直接继续下次循环

### 数组操作

##### 遍历数组

for循环或者for each循环（无法获取索引）；Arrays.toString()可以快速打印数组内容

##### 数组排序

常用的排序算法：冒泡排序、插入排序、快速排序

Arrays.sort()根据数据的大小和类型来选择最高效的算法

##### 多维数组

##### 命令行参数

Java程序的入口是main方法，可以接受一个命令行参数：

```java
public static void main(String[] args) {}
```

必须在命令行中执行才能传入参数：

```
$ javac Main.java  //先编译
$ java Main str1 str2 str3 //可以通过空格分隔的方式传入字符串数组
//针对传入参数的使用则取决于代码内容
```

